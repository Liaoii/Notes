## 3. 注解

### 3.1 @TableName

如果表名与实体类的名称不一致，MyBatis Plus将无法自动进行映射

**解决办法一**：在实体上通过@TableName注解指定表名

```java
@Data
@TableName("t_user")
public class User {
    /**
     * 这里要使用包装类
     */
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

**解决方法二**：在全局配置文件中添加公共前缀

```yaml
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      table-prefix: t_
```

### 3.2 @TableId

MyBatis Plus默认将id作为主键，如果将主键是其他名称，MyBatis Plus将无法使用雪花算法为其自动赋值

解决方法：使用@TableId将属性所对应的字段指定为主键

```java
@Data
public class User {

    @TableId
    private Long uid;
    private String name;
    private Integer age;
    private String email;
}
```

如果实体类的属性名称与表字段的名称不一致，则需要通过@TableId的value属性指定

```java
@Data
public class User {

    @TableId("uid")
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

主键生成策略：通过@TableId注解的type属性可以设置主键生成策略，默认为雪花算法

要想将主键生成策略设置成自增，首先需要将数据库中主键字段设置成自增，然后通过@TableId的type属性指定为IdType.AUTO

```java
@Data
public class User {

    @TableId(value = "uid", type = IdType.AUTO)
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

如果在插入时主动为主键赋了值，那么不会使用自动生成主键，而是使用主动赋值的值

**通过全局配置设置主键生成策略**：

```yaml
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      table-prefix: t_
      id-type: AUTO
```

### 3.3 雪花算法

雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的主键的有序性

雪花算法生成的值长度为64位：

​		第一位为符号位，正数为0，负数为1，id一般为正数，也就是0

​		41位为时间戳（毫秒级），存储的是时间戳的差值（当前时间戳 - 开始时间戳）

​		10位为机器ID（5位是数据中心，5位是机器ID，可以部署在1024个节点）

​		12位为毫秒内的流水号，意味着每个节点在每毫秒可以产生4096个ID

雪花算法整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，效率较高

### 3.4 @TableField

如果实体类的非主键属性与数据库中表的字段不一致，则可以使用@TableField进行映射

```java
@Data
public class User {

    @TableId(value = "uid")
    private Long id;
    @TableField("user_name")
    private String name;
    private Integer age;
    private String email;
}
```

### 3.5 @TableLogic

在数据库表中新增一个is_deleted字段，默认为0

修改实体类：

```java
@Data
public class User {

    @TableId(value = "uid")
    private Long id;
    @TableField("user_name")
    private String name;
    private Integer age;
    private String email;
    @TableLogic
    private Integer isDeleted;
}
```

测试删除操作：

```java
@SpringBootTest
public class MyBatisPlusTest {
    @Test
    public void testDeleteBatchIds() {
        List<Long> list = Arrays.asList(1L, 2L, 3L);
        int result = userMapper.deleteBatchIds(list);
        System.out.println("result: " + result);
    }
}
```

结果：删除操作变成了更新操作，将is_deleted字段置为1	

```
==>  Preparing: UPDATE t_user SET is_deleted=1 WHERE uid IN ( ? , ? , ? ) AND is_deleted=0
==> Parameters: 1(Long), 2(Long), 3(Long)
<==    Updates: 3
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@34b27915]
result: 3
```

测试查询：

```java
@SpringBootTest
public class MyBatisPlusTest {
    @Test
    public void testSelectList() {
        List<User> users = userMapper.selectList(null);
        users.forEach(System.out::println);
    }
}
```

结果：

```
==>  Preparing: SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0
==> Parameters: 
<==    Columns: id, name, age, email, is_deleted
<==        Row: 4, Sandy, 21, test4@baomidou.com, 0
<==        Row: 5, Billie, 24, test5@baomidou.com, 0
<==        Row: 6, 张珊, 18, zs@qq.com, 0
<==      Total: 3
```

